# espanso match file
# For a complete introduction, visit the official docs at: https://espanso.org/docs/

matches:
  # ==============================================================================
  # React Hooks
  # ==============================================================================
  - trigger: ':react.hook list'
    replace: |
      useFetch
      usePrevious
      useToggle
      useLocalStorage
      useDebounce
      useInterval
      useWindowSize
      useOnClickOutside
      useHover
      useMediaQuery
      useWebSocket
      useInfiniteScroll
      useLocalStorage
      useThrottle
      useArrayState

  
  - trigger: ':react.hook useFetch'
    replace: |
      import { useState, useEffect } from 'react';

      function useFetch(url) {
        const [data, setData] = useState(null);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        useEffect(() => {
          const fetchData = async () => {
            try {
              const response = await fetch(url);
              const result = await response.json();
              setData(result);
            } catch (err) {
              setError(err);
            } finally {
              setLoading(false);
            }
          };
          fetchData();
        }, [url]);

        return { data, loading, error };
      }

      // Usage:
      const { data, loading, error } = useFetch('https://api.example.com/data');

  - trigger: ':react.hook usePrevious'
    replace: |
      import { useRef, useEffect } from 'react';

      function usePrevious(value) {
        const ref = useRef();

        useEffect(() => {
          ref.current = value;
        }, [value]);

        return ref.current;
      }

      // Usage:
      const previousCount = usePrevious(count);

  - trigger: ':react.hook useToggle'
    replace: |
      import { useState } from 'react';

      function useToggle(initialValue = false) {
        const [value, setValue] = useState(initialValue);

        const toggle = () => setValue(prev => !prev);

        return [value, toggle];
      }

      // Usage:
      const [isToggled, toggle] = useToggle();

  - trigger: ':react.hook useLocalStorage'
    replace: |
      import { useState } from 'react';

      function useLocalStorage(key, initialValue) {
        const [storedValue, setStoredValue] = useState(() => {
          try {
            const item = localStorage.getItem(key);
            return item ? JSON.parse(item) : initialValue;
          } catch (error) {
            console.log(error);
            return initialValue;
          }
        });

        const setValue = value => {
          try {
            setStoredValue(value);
            localStorage.setItem(key, JSON.stringify(value));
          } catch (error) {
            console.log(error);
          }
        };

        return [storedValue, setValue];
      }

      // Usage:
      const [name, setName] = useLocalStorage('name', 'Guest');

  - trigger: ':react.hook useDebounce'
    replace: |
      import { useState, useEffect } from 'react';

      function useDebounce(value, delay) {
        const [debouncedValue, setDebouncedValue] = useState(value);

        useEffect(() => {
          const handler = setTimeout(() => {
            setDebouncedValue(value);
          }, delay);

          return () => clearTimeout(handler);
        }, [value, delay]);

        return debouncedValue;
      }

      // Usage:
      const debouncedSearchTerm = useDebounce(searchTerm, 500);

  - trigger: ':react.hook useInterval'
    replace: |
      import { useEffect, useRef } from 'react';

      function useInterval(callback, delay) {
        const savedCallback = useRef();

        useEffect(() => {
          savedCallback.current = callback;
        }, [callback]);

        useEffect(() => {
          if (delay !== null) {
            const id = setInterval(() => savedCallback.current(), delay);
            return () => clearInterval(id);
          }
        }, [delay]);
      }

      // Usage:
      useInterval(() => {
        setCount(prevCount => prevCount + 1);
      }, 1000);

  - trigger: ':react.hook useWindowSize'
    replace: |
      import { useState, useEffect } from 'react';

      function useWindowSize() {
        const [windowSize, setWindowSize] = useState({
          width: window.innerWidth,
          height: window.innerHeight,
        });

        useEffect(() => {
          const handleResize = () => {
            setWindowSize({
              width: window.innerWidth,
              height: window.innerHeight,
            });
          };
          window.addEventListener('resize', handleResize);
          return () => window.removeEventListener('resize', handleResize);
        }, []);

        return windowSize;
      }

      Usage:
      const { width, height } = useWindowSize();

  - trigger: ':react.hook useOnClickOutside'
    replace: |
      import { useEffect } from 'react';

      function useOnClickOutside(ref, handler) {
        useEffect(() => {
          const listener = event => {
            if (!ref.current || ref.current.contains(event.target)) return;
            handler(event);
          };
          document.addEventListener('mousedown', listener);
          document.addEventListener('touchstart', listener);
          return () => {
            document.removeEventListener('mousedown', listener);
            document.removeEventListener('touchstart', listener);
          };
        }, [ref, handler]);
      }

      // Usage:
      const modalRef = useRef();
      useOnClickOutside(modalRef, () => setIsOpen(false));

  - trigger: ':react.hook useHover'
    replace: |
      import { useState, useRef, useEffect } from 'react';

      function useHover() {
        const [hovered, setHovered] = useState(false);
        const ref = useRef(null);

        useEffect(() => {
          const handleMouseOver = () => setHovered(true);
          const handleMouseOut = () => setHovered(false);
          const node = ref.current;
          if (node) {
            node.addEventListener('mouseover', handleMouseOver);
            node.addEventListener('mouseout', handleMouseOut);
          }
          return () => {
            if (node) {
              node.removeEventListener('mouseover', handleMouseOver);
              node.removeEventListener('mouseout', handleMouseOut);
            }
          };
        }, [ref]);

        return [ref, hovered];
      }

      Usage:
      const [hoverRef, isHovered] = useHover();

  - trigger: ':react.hook useMediaQuery'
    replace: |
      import { useEffect, useState } from 'react';

      function useMediaQuery(query) {
        const [matches, setMatches] = useState(false);

        useEffect(() => {
          const mediaQuery = window.matchMedia(query);
          setMatches(mediaQuery.matches);

          const handler = event => setMatches(event.matches);
          mediaQuery.addEventListener('change', handler);

          return () => mediaQuery.removeEventListener('change', handler);
        }, [query]);

        return matches;
      }

      // Usage:
      const isLargeScreen = useMediaQuery('(min-width: 1024px)');

  - trigger: ':react.hook useWebSocket'
    replace: |
      import { useState, useEffect, useRef, useCallback } from 'react';

      function useWebSocket(url, options = {}) {
        const { reconnect = true, reconnectInterval = 5000, onOpen, onMessage, onError, onClose } = options;
        const [isConnected, setIsConnected] = useState(false);
        const [lastMessage, setLastMessage] = useState(null);
        const websocketRef = useRef(null);
        const reconnectTimeout = useRef(null);

        const connect = useCallback(() => {
          websocketRef.current = new WebSocket(url);

          websocketRef.current.onopen = (event) => {
            setIsConnected(true);
            onOpen && onOpen(event);
          };

          websocketRef.current.onmessage = (event) => {
            setLastMessage(event.data);
            onMessage && onMessage(event);
          };

          websocketRef.current.onerror = (event) => {
            onError && onError(event);
          };

          websocketRef.current.onclose = (event) => {
            setIsConnected(false);
            onClose && onClose(event);
            if (reconnect) {
              reconnectTimeout.current = setTimeout(connect, reconnectInterval);
            }
          };
        }, [url, reconnect, reconnectInterval, onOpen, onMessage, onError, onClose]);

        const sendMessage = useCallback((message) => {
          if (isConnected && websocketRef.current) {
            websocketRef.current.send(message);
          }
        }, [isConnected]);

        useEffect(() => {
          connect();

          return () => {
            if (websocketRef.current) {
              websocketRef.current.close();
            }
            clearTimeout(reconnectTimeout.current);
          };
        }, [connect]);

        return { isConnected, sendMessage, lastMessage };
      }

      // Usage:
      const { isConnected, sendMessage, lastMessage } = useWebSocket('ws://localhost:4000/chat', {
        reconnect: true,
        reconnectInterval: 3000,
        onOpen: () => console.log('Connected to WebSocket'),
        onMessage: (event) => console.log('New message received:', event.data),
        onClose: () => console.log('Disconnected from WebSocket'),
      });

      const [inputValue, setInputValue] = useState('');

      const handleSend = () => {
        sendMessage(inputValue);
        setInputValue('');
      };

  - trigger: ':react.hook useInfiniteScroll'
    replace: |
      import { useState, useEffect, useRef, useCallback } from 'react';

      function useInfiniteScroll(fetchData, options = {}) {
        const { threshold = 0.8, hasMore = true } = options;
        const [data, setData] = useState([]);
        const [loading, setLoading] = useState(false);
        const [error, setError] = useState(null);
        const observerRef = useRef();

        const loadMore = useCallback(async () => {
          if (loading || !hasMore) return;
          setLoading(true);
          setError(null);
          try {
            const newData = await fetchData();
            setData((prevData) => [...prevData, ...newData]);
          } catch (err) {
            setError(err);
          } finally {
            setLoading(false);
          }
        }, [fetchData, loading, hasMore]);

        useEffect(() => {
          if (!hasMore) return;
          
          const observer = new IntersectionObserver(
            (entries) => {
              if (entries[0].isIntersecting) {
                loadMore();
              }
            },
            { threshold }
          );
          
          if (observerRef.current) observer.observe(observerRef.current);
          
          return () => {
            if (observerRef.current) observer.unobserve(observerRef.current);
          };
        }, [loadMore, hasMore, threshold]);

        return { data, loading, error, observerRef };
      }

      // Usage:
      function InfiniteScrollList() {
        const fetchMoreData = async () => {
          const response = await fetch('/api/data'); // Example API
          return response.json();
        };

        const { data, loading, error, observerRef } = useInfiniteScroll(fetchMoreData, {
          threshold: 0.9,
          hasMore: true
        });

        return (
          <div>
            {data.map((item, index) => (
              <div key={index}>{item}</div>
            ))}
            <div ref={observerRef} style={{ height: '1px' }} />
            {loading && <p>Loading...</p>}
            {error && <p>Error loading data...</p>}
          </div>
        );
      }

  - trigger: ':react.hook useLocalStorage'
    replace: |
      import { useState } from 'react';

      function useLocalStorage(key, initialValue) {
        const [storedValue, setStoredValue] = useState(() => {
          try {
            const item = localStorage.getItem(key);
            return item ? JSON.parse(item) : initialValue;
          } catch (error) {
            console.log(error);
            return initialValue;
          }
        });

        const setValue = value => {
          try {
            setStoredValue(value);
            localStorage.setItem(key, JSON.stringify(value));
          } catch (error) {
            console.log(error);
          }
        };

        return [storedValue, setValue];
      }

      Usage:
      const [name, setName] = useLocalStorage('name', 'Guest');
  
  - trigger: ':react.hook useThrottle'
    replace: |
      import { useRef } from 'react';

      function useThrottle(callback, delay) {
        const lastCall = useRef(0);

        return (...args) => {
          const now = new Date().getTime();

          if (now - lastCall.current >= delay) {
            lastCall.current = now;
            callback(...args);
          }
        };
      }

      // Usage:
      function ThrottledScroll() {
        const handleScroll = useThrottle(() => {
          console.log('Scrolled!');
        }, 200);

        useEffect(() => {
          window.addEventListener('scroll', handleScroll);
          return () => window.removeEventListener('scroll', handleScroll);
        }, [handleScroll]);

        return <div style={{ height: '2000px' }}>Scroll down to see throttled console logs.</div>;
      }

  - trigger: ":react.hook useArrayState"
    replace: |
      import { useState } from "react";

      const useArrayState = <T>(initialState: T[] = []) => {
      const [state, setState] = useState<T[]>(initialState);

      const add = (newValue: T) => {
          setState((currentState) => [...currentState, newValue]);
      };

      const remove = (index: number) => {
          setState((currentState) => {
              const newState = [...currentState];
              if (index >= 0 && index < newState.length) {
                  newState.splice(index, 1);
              }
              return newState;
          });
      };

      const update = (index: number, newValue: T) => {
          setState((currentState) => {
              const newState = [...currentState];
              if (index >= 0 && index < newState.length) {
                  newState[index] = newValue;
              }
              return newState;
          });
      };

      const clear = () => {
          setState([]);
      };

      const reset = () => {
          setState(initialState);
      };

      return [state, { add, remove, update, clear, reset }] as const;
      };

      export default useArrayState;

